<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Fixes Round 2 Test Suite - Anamnese-A</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        h1 {
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .subtitle {
            color: #fff;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .test-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }
        .test-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .test-severity {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .severity-critical {
            background: #dc3545;
            color: white;
        }
        .severity-high {
            background: #fd7e14;
            color: white;
        }
        .severity-medium {
            background: #ffc107;
            color: #000;
        }
        .test-description {
            color: #666;
            margin-bottom: 15px;
            font-size: 14px;
        }
        .test-result {
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-weight: 500;
            border: 2px solid;
        }
        .test-result.pass {
            background: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }
        .test-result.fail {
            background: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }
        .test-result.running {
            background: #fff3cd;
            color: #856404;
            border-color: #ffeeba;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .log {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 12px;
            border: 1px solid #dee2e6;
        }
        .run-all-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            font-size: 18px;
            padding: 15px 40px;
            display: block;
            margin: 30px auto;
        }
        .stats {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-item {
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª Anamnese-A Bug Fixes - Round 2</h1>
    <p class="subtitle">Static Analysis Follow-Up: 5 Additional Critical Issues</p>

    <div class="stats">
        <h3>Test Statistics</h3>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value" id="total-tests">5</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="passed-tests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="failed-tests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="runtime">0s</div>
                <div class="stat-label">Total Runtime</div>
            </div>
        </div>
    </div>

    <div class="test-container">
        <div class="test-title">
            <span>Test #8: SafeJSON - Corrupted Data Handling</span>
            <span class="test-severity severity-critical">CRITICAL</span>
        </div>
        <div class="test-description">
            Testet ob SafeJSON.parse() App-Crashes bei korruptem JSON verhindert.<br>
            <strong>User Impact:</strong> "App stÃ¼rzt ab beim Laden alter Daten!"
        </div>
        <button onclick="testSafeJSON()">Test starten</button>
        <div id="test8-result"></div>
        <div id="test8-log" class="log"></div>
    </div>

    <div class="test-container">
        <div class="test-title">
            <span>Test #9: loadDocuments() Mutex Lock</span>
            <span class="test-severity severity-high">HIGH</span>
        </div>
        <div class="test-description">
            Testet ob parallele loadDocuments() Aufrufe durch Mutex verhindert werden.<br>
            <strong>User Impact:</strong> "Dokumente verschwinden manchmal!"
        </div>
        <button onclick="testLoadDocumentsMutex()">Test starten</button>
        <div id="test9-result"></div>
        <div id="test9-log" class="log"></div>
    </div>

    <div class="test-container">
        <div class="test-title">
            <span>Test #10: EventListenerManager - Memory Leak Prevention</span>
            <span class="test-severity severity-medium">MEDIUM</span>
        </div>
        <div class="test-description">
            Testet ob Event Listeners korrekt getrackt und entfernt werden.<br>
            <strong>User Impact:</strong> "App wird immer langsamer!"
        </div>
        <button onclick="testEventListenerManager()">Test starten</button>
        <div id="test10-result"></div>
        <div id="test10-log" class="log"></div>
    </div>

    <div class="test-container">
        <div class="test-title">
            <span>Test #11: fetchWithTimeout - Abort Controller</span>
            <span class="test-severity severity-high">HIGH</span>
        </div>
        <div class="test-description">
            Testet ob fetch() Aufrufe nach Timeout abgebrochen werden.<br>
            <strong>User Impact:</strong> "Bezahlseite hÃ¤ngt ewig!"
        </div>
        <button onclick="testFetchTimeout()">Test starten</button>
        <div id="test11-result"></div>
        <div id="test11-log" class="log"></div>
    </div>

    <div class="test-container">
        <div class="test-title">
            <span>Test #12: Safe Destructuring - Type Validation</span>
            <span class="test-severity severity-medium">MEDIUM</span>
        </div>
        <div class="test-description">
            Testet ob Destructuring mit Schema-Validierung geschÃ¼tzt ist.<br>
            <strong>User Impact:</strong> "TypeError beim Restore!"
        </div>
        <button onclick="testSafeDestructuring()">Test starten</button>
        <div id="test12-result"></div>
        <div id="test12-log" class="log"></div>
    </div>

    <button class="run-all-btn" onclick="runAllTests()">ðŸš€ Alle Tests ausfÃ¼hren</button>

    <script>
        let startTime = 0;
        let passedCount = 0;
        let failedCount = 0;

        // Helper functions
        function log(testId, message) {
            const logDiv = document.getElementById(`test${testId}-log`);
            const timestamp = new Date().toISOString().substr(11,12);
            logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function setResult(testId, passed, message) {
            const resultDiv = document.getElementById(`test${testId}-result`);
            resultDiv.className = `test-result ${passed ? 'pass' : 'fail'}`;
            resultDiv.innerHTML = passed ? `âœ… PASSED: ${message}` : `âŒ FAILED: ${message}`;
            
            if (passed) passedCount++;
            else failedCount++;
            
            updateStats();
        }

        function setRunning(testId) {
            const resultDiv = document.getElementById(`test${testId}-result`);
            resultDiv.className = 'test-result running';
            resultDiv.innerHTML = 'â³ Test lÃ¤uft...';
        }

        function updateStats() {
            document.getElementById('passed-tests').textContent = passedCount;
            document.getElementById('failed-tests').textContent = failedCount;
            const runtime = ((Date.now() - startTime) / 1000).toFixed(2);
            document.getElementById('runtime').textContent = runtime + 's';
        }

        // TEST #8: SafeJSON
        async function testSafeJSON() {
            setRunning(8);
            log(8, 'Starting SafeJSON test...');

            // Implementation of SafeJSON from fix
            const SafeJSON = {
                parse(jsonString, defaultValue = null) {
                    if (!jsonString || typeof jsonString !== 'string') {
                        return defaultValue;
                    }
                    try {
                        return JSON.parse(jsonString);
                    } catch (e) {
                        console.error('[SafeJSON] Parse error:', e.message);
                        return defaultValue;
                    }
                },
                
                parseWithSchema(jsonString, schema, defaultValue = null) {
                    const parsed = this.parse(jsonString, null);
                    if (parsed === null) return defaultValue;
                    
                    for (const key of Object.keys(schema)) {
                        if (!(key in parsed)) {
                            console.warn(`[SafeJSON] Missing required key: ${key}`);
                            return defaultValue;
                        }
                    }
                    return parsed;
                }
            };

            let allPassed = true;

            // Test 1: Valid JSON
            const validJSON = '{"name":"test","value":123}';
            const result1 = SafeJSON.parse(validJSON);
            const test1 = result1 && result1.name === 'test';
            log(8, `Test 1 (valid JSON): ${test1 ? 'PASS' : 'FAIL'}`);
            allPassed = allPassed && test1;

            // Test 2: Corrupted JSON (should not crash!)
            const corruptedJSON = '{name: "test", invalid}';
            const result2 = SafeJSON.parse(corruptedJSON, { fallback: true });
            const test2 = result2 && result2.fallback === true;
            log(8, `Test 2 (corrupted JSON with fallback): ${test2 ? 'PASS' : 'FAIL'}`);
            allPassed = allPassed && test2;

            // Test 3: Null input
            const result3 = SafeJSON.parse(null, []);
            const test3 = Array.isArray(result3) && result3.length === 0;
            log(8, `Test 3 (null input): ${test3 ? 'PASS' : 'FAIL'}`);
            allPassed = allPassed && test3;

            // Test 4: Schema validation - valid
            const validWithSchema = '{"answers":{},"currentSection":0,"timestamp":"2024-01-01"}';
            const schema = { answers: {}, currentSection: 0, timestamp: '' };
            const result4 = SafeJSON.parseWithSchema(validWithSchema, schema);
            const test4 = result4 !== null && result4.answers !== undefined;
            log(8, `Test 4 (schema validation - valid): ${test4 ? 'PASS' : 'FAIL'}`);
            allPassed = allPassed && test4;

            // Test 5: Schema validation - missing key
            const invalidSchema = '{"answers":{}}'; // missing currentSection
            const result5 = SafeJSON.parseWithSchema(invalidSchema, schema, { error: true });
            const test5 = result5 && result5.error === true;
            log(8, `Test 5 (schema validation - missing key): ${test5 ? 'PASS' : 'FAIL'}`);
            allPassed = allPassed && test5;

            if (allPassed) {
                setResult(8, true, 'SafeJSON prevents crashes from corrupted data');
            } else {
                setResult(8, false, 'Some SafeJSON tests failed');
            }
        }

        // TEST #9: loadDocuments() Mutex
        async function testLoadDocumentsMutex() {
            setRunning(9);
            log(9, 'Starting Mutex test...');

            // Simulate loadDocuments with mutex
            let loadDocumentsPromise = null;
            let callCount = 0;
            let loadCount = 0;

            async function mockLoadDocuments() {
                callCount++;
                log(9, `Call #${callCount} started`);

                if (loadDocumentsPromise !== null) {
                    log(9, `Call #${callCount} using cached promise (MUTEX WORKED!)`);
                    return loadDocumentsPromise;
                }

                loadDocumentsPromise = (async () => {
                    loadCount++;
                    log(9, `Call #${callCount} creating new promise (actual load #${loadCount})`);
                    await new Promise(r => setTimeout(r, 200));
                    return 'documents-loaded';
                })();

                try {
                    return await loadDocumentsPromise;
                } finally {
                    loadDocumentsPromise = null;
                }
            }

            // Simulate 5 parallel calls
            const promises = [
                mockLoadDocuments(),
                mockLoadDocuments(),
                mockLoadDocuments(),
                mockLoadDocuments(),
                mockLoadDocuments()
            ];

            const results = await Promise.all(promises);
            
            log(9, `All calls completed. Total calls: ${callCount}, Actual loads: ${loadCount}`);

            // Expected: 5 calls, but only 1 actual load (rest use mutex)
            if (callCount === 5 && loadCount === 1) {
                setResult(9, true, 'Mutex prevents race conditions! 5 calls â†’ 1 load');
            } else {
                setResult(9, false, `Expected 1 load, got ${loadCount} (race condition!)`);
            }
        }

        // TEST #10: EventListenerManager
        async function testEventListenerManager() {
            setRunning(10);
            log(10, 'Starting EventListenerManager test...');

            const EventListenerManager = {
                listeners: new Map(),
                
                add(element, eventType, handler) {
                    const key = this._getKey(element, eventType, handler);
                    if (this.listeners.has(key)) {
                        this.remove(element, eventType, handler);
                    }
                    element.addEventListener(eventType, handler);
                    this.listeners.set(key, { element, eventType, handler });
                },
                
                remove(element, eventType, handler) {
                    const key = this._getKey(element, eventType, handler);
                    const listener = this.listeners.get(key);
                    if (listener) {
                        element.removeEventListener(eventType, handler);
                        this.listeners.delete(key);
                    }
                },
                
                removeAllForElement(element) {
                    const toRemove = [];
                    for (const [key, listener] of this.listeners.entries()) {
                        if (listener.element === element) {
                            toRemove.push(key);
                        }
                    }
                    toRemove.forEach(key => {
                        const listener = this.listeners.get(key);
                        listener.element.removeEventListener(listener.eventType, listener.handler);
                        this.listeners.delete(key);
                    });
                },
                
                clearAll() {
                    for (const [key, listener] of this.listeners.entries()) {
                        listener.element.removeEventListener(listener.eventType, listener.handler);
                    }
                    this.listeners.clear();
                },
                
                _getKey(element, eventType, handler) {
                    const elementId = element.id || Math.random().toString(36).substr(2, 9);
                    return elementId + '_' + eventType;
                }
            };

            const testButton = document.createElement('button');
            testButton.id = 'test-button';
            let clickCount = 0;
            const handler = () => { clickCount++; };

            // Test 1: Add listener
            EventListenerManager.add(testButton, 'click', handler);
            log(10, `Test 1: Added listener. Tracked: ${EventListenerManager.listeners.size}`);
            const test1 = EventListenerManager.listeners.size === 1;

            // Test 2: Add duplicate (should replace, not add)
            EventListenerManager.add(testButton, 'click', handler);
            log(10, `Test 2: Added duplicate. Tracked: ${EventListenerManager.listeners.size}`);
            const test2 = EventListenerManager.listeners.size === 1;

            // Test 3: Multiple listeners
            const handler2 = () => {};
            const testButton2 = document.createElement('button');
            testButton2.id = 'test-button-2';
            EventListenerManager.add(testButton2, 'click', handler2);
            log(10, `Test 3: Added second element. Tracked: ${EventListenerManager.listeners.size}`);
            const test3 = EventListenerManager.listeners.size === 2;

            // Test 4: Remove all for element
            EventListenerManager.removeAllForElement(testButton);
            log(10, `Test 4: Removed all for element 1. Tracked: ${EventListenerManager.listeners.size}`);
            const test4 = EventListenerManager.listeners.size === 1;

            // Test 5: Clear all
            EventListenerManager.clearAll();
            log(10, `Test 5: Cleared all. Tracked: ${EventListenerManager.listeners.size}`);
            const test5 = EventListenerManager.listeners.size === 0;

            if (test1 && test2 && test3 && test4 && test5) {
                setResult(10, true, 'EventListenerManager prevents memory leaks');
            } else {
                setResult(10, false, 'Some EventListenerManager tests failed');
            }
        }

        // TEST #11: fetchWithTimeout
        async function testFetchTimeout() {
            setRunning(11);
            log(11, 'Starting Fetch Timeout test...');

            async function fetchWithTimeout(url, options = {}, timeout = 1000) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                }, timeout);
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    return response;
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error('Request timeout after ' + (timeout / 1000) + 's');
                    }
                    throw error;
                }
            }

            let test1 = false;
            let test2 = false;

            // Test 1: Fast request (should succeed)
            try {
                log(11, 'Test 1: Fast request (timeout 5s)...');
                const url1 = 'data:text/plain,hello';
                const response1 = await fetchWithTimeout(url1, {}, 5000);
                test1 = response1.ok;
                log(11, `Test 1: ${test1 ? 'PASS' : 'FAIL'}`);
            } catch (e) {
                log(11, `Test 1: FAIL - ${e.message}`);
            }

            // Test 2: Simulate slow request (should timeout)
            try {
                log(11, 'Test 2: Slow request (timeout 100ms) - should abort...');
                // Use a never-resolving promise to simulate slow request
                const slowFetch = () => new Promise((resolve) => {
                    setTimeout(() => resolve({ ok: true }), 10000);
                });
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 100);
                
                try {
                    await slowFetch();
                    clearTimeout(timeoutId);
                    log(11, 'Test 2: FAIL - No timeout occurred');
                } catch (e) {
                    clearTimeout(timeoutId);
                    if (e.name === 'AbortError') {
                        test2 = true;
                        log(11, 'Test 2: PASS - Request aborted correctly');
                    }
                }
            } catch (e) {
                test2 = e.message.includes('timeout');
                log(11, `Test 2: ${test2 ? 'PASS' : 'FAIL'} - ${e.message}`);
            }

            // Simplified test 2: Just verify timeout logic works
            const startTime = Date.now();
            const controller = new AbortController();
            setTimeout(() => controller.abort(), 100);
            
            try {
                await fetch('https://httpbin.org/delay/10', { signal: controller.signal });
            } catch (e) {
                const elapsed = Date.now() - startTime;
                test2 = e.name === 'AbortError' && elapsed < 500;
                log(11, `Test 2: ${test2 ? 'PASS' : 'FAIL'} - Aborted after ${elapsed}ms`);
            }

            if (test1 && test2) {
                setResult(11, true, 'fetchWithTimeout aborts slow requests');
            } else {
                setResult(11, false, `Tests: fast=${test1}, slow=${test2}`);
            }
        }

        // TEST #12: Safe Destructuring
        async function testSafeDestructuring() {
            setRunning(12);
            log(12, 'Starting Safe Destructuring test...');

            // Simulate SafeJSON.parseWithSchema
            const SafeJSON = {
                parseWithSchema(jsonString, schema, defaultValue = null) {
                    if (!jsonString) return defaultValue;
                    
                    try {
                        const parsed = JSON.parse(jsonString);
                        
                        // Validate schema
                        for (const key of Object.keys(schema)) {
                            if (!(key in parsed)) {
                                return defaultValue;
                            }
                        }
                        return parsed;
                    } catch (e) {
                        return defaultValue;
                    }
                }
            };

            function safeRestore(savedData) {
                const schema = { answers: {}, currentSection: 0, timestamp: '' };
                const parsed = SafeJSON.parseWithSchema(savedData, schema, null);
                
                if (!parsed) return { success: false, reason: 'Invalid data' };
                
                const { answers, currentSection, timestamp } = parsed;
                
                // Validate types
                if (typeof answers !== 'object' || answers === null) {
                    return { success: false, reason: 'Invalid answers type' };
                }
                
                if (typeof currentSection !== 'number' || isNaN(currentSection)) {
                    return { success: false, reason: 'Invalid currentSection' };
                }
                
                if (!timestamp) {
                    return { success: false, reason: 'Missing timestamp' };
                }
                
                return { success: true, answers, currentSection, timestamp };
            }

            // Test 1: Valid data
            const valid = '{"answers":{"q1":"a1"},"currentSection":1,"timestamp":"2024-01-01"}';
            const result1 = safeRestore(valid);
            const test1 = result1.success === true;
            log(12, `Test 1 (valid data): ${test1 ? 'PASS' : 'FAIL'}`);

            // Test 2: Missing required field
            const missingField = '{"answers":{},"currentSection":1}';
            const result2 = safeRestore(missingField);
            const test2 = result2.success === false && result2.reason === 'Invalid data';
            log(12, `Test 2 (missing field): ${test2 ? 'PASS' : 'FAIL'} - ${result2.reason}`);

            // Test 3: Invalid type (answers is string, not object)
            const invalidType = '{"answers":"invalid","currentSection":1,"timestamp":"2024-01-01"}';
            const result3 = safeRestore(invalidType);
            const test3 = result3.success === false && result3.reason === 'Invalid answers type';
            log(12, `Test 3 (invalid type): ${test3 ? 'PASS' : 'FAIL'} - ${result3.reason}`);

            // Test 4: Corrupted JSON
            const corrupted = '{answers: invalid}';
            const result4 = safeRestore(corrupted);
            const test4 = result4.success === false;
            log(12, `Test 4 (corrupted JSON): ${test4 ? 'PASS' : 'FAIL'}`);

            // Test 5: Null input
            const result5 = safeRestore(null);
            const test5 = result5.success === false;
            log(12, `Test 5 (null input): ${test5 ? 'PASS' : 'FAIL'}`);

            if (test1 && test2 && test3 && test4 && test5) {
                setResult(12, true, 'Safe destructuring prevents TypeErrors');
            } else {
                setResult(12, false, 'Some safe destructuring tests failed');
            }
        }

        // Run all tests
        async function runAllTests() {
            startTime = Date.now();
            passedCount = 0;
            failedCount = 0;
            
            await testSafeJSON();
            await new Promise(r => setTimeout(r, 300));
            
            await testLoadDocumentsMutex();
            await new Promise(r => setTimeout(r, 300));
            
            await testEventListenerManager();
            await new Promise(r => setTimeout(r, 300));
            
            await testFetchTimeout();
            await new Promise(r => setTimeout(r, 300));
            
            await testSafeDestructuring();
            
            updateStats();
            
            // Show summary
            const allPassed = failedCount === 0;
            const message = allPassed 
                ? 'âœ… All tests passed! Round 2 fixes are working correctly.'
                : `âš ï¸ ${failedCount} test(s) failed. Please review the logs.`;
            
            setTimeout(() => alert(message), 500);
        }
    </script>
</body>
</html>
