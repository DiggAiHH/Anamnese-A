<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Anamnese-A (offline)</title>

  <!--
    CSP tightened for offline usage.
    Note: 'unsafe-inline' kept because this page contains inline scripts/styles.
  -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data: blob:; style-src 'self' 'unsafe-inline'; font-src 'self' data:; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; worker-src 'self' blob:; connect-src 'self' blob:; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'" />

  <!-- Local libs (no CDN) -->
  <!-- pdf.js -->
  <script src="lib/pdf.min.js"></script>
  <!-- pdf.js worker is configured in code: lib/pdf.worker.min.js -->

  <!-- tesseract.js (local build) -->
  <script src="lib/tesseract.min.js"></script>

  <!-- crypto-js (local build) -->
  <script src="lib/crypto-js.min.js"></script>

  <style>
    /* Existing styles preserved */
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;margin:0;background:#0b1220;color:#e6eefc}
    header{padding:14px 18px;background:#0f1a33;border-bottom:1px solid rgba(255,255,255,.08)}
    .container{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:#0f1a33;border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:16px;margin:12px 0}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>*{flex:1}
    button,input,select,textarea{background:#0b1220;color:#e6eefc;border:1px solid rgba(255,255,255,.14);border-radius:8px;padding:10px 12px}
    button{cursor:pointer}
    button:hover{border-color:rgba(255,255,255,.28)}
    .muted{color:#b8c7e6}
    .small{font-size:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .danger{color:#ffb4b4}
    .success{color:#b7ffcf}
    .pill{display:inline-block;padding:2px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    details summary{cursor:pointer}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b1220;border:1px solid rgba(255,255,255,.10);padding:10px;border-radius:10px}
    .drop{border:2px dashed rgba(255,255,255,.22);border-radius:10px;padding:18px;text-align:center}
    .drop.drag{border-color:#91b6ff;background:rgba(145,182,255,.08)}
  </style>
</head>

<body>
<header>
  <div class="container">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
      <div>
        <div style="font-weight:700">Anamnese-A</div>
        <div class="muted small">V8 complete · vollständig offline (lokale Libs)</div>
      </div>
      <div class="small muted">Dateien bleiben lokal · keine externen CDNs</div>
    </div>
  </div>
</header>

<div class="container">
  <div class="card">
    <div class="row">
      <div>
        <div class="pill">Upload</div>
        <p class="muted small">PDF oder Bilder (PNG/JPG) in den Dropbereich ziehen oder auswählen.</p>
        <div id="drop" class="drop">
          <div style="font-weight:600">Datei hier ablegen</div>
          <div class="muted small">oder</div>
          <div style="margin-top:8px"><input id="file" type="file" multiple /></div>
        </div>
      </div>
      <div>
        <div class="pill">Status</div>
        <div id="status" class="muted small" style="margin-top:10px">Bereit.</div>
        <div style="margin-top:10px" class="row">
          <button id="btnRun">Verarbeiten</button>
          <button id="btnClear">Zurücksetzen</button>
        </div>
        <details style="margin-top:12px">
          <summary class="muted small">Einstellungen</summary>
          <div style="margin-top:10px" class="grid">
            <label class="small">OCR Sprache
              <select id="lang">
                <option value="deu" selected>Deutsch (deu)</option>
                <option value="eng">English (eng)</option>
              </select>
            </label>
            <label class="small">PDF Render Scale
              <input id="scale" type="number" step="0.5" min="1" max="5" value="2" />
            </label>
          </div>
          <p class="muted small">Hinweis: Tesseract benötigt lokale Sprachdaten in <span class="mono">lib/tessdata/</span> oder per Worker-Konfiguration.</p>
        </details>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="pill">Output</div>
    <div class="row" style="margin-top:10px">
      <button id="btnCopy">Text kopieren</button>
      <button id="btnDownload">Text herunterladen</button>
    </div>
    <pre id="out" class="mono" style="margin-top:10px;min-height:180px"></pre>
  </div>

  <div class="card">
    <div class="pill">Debug</div>
    <div class="muted small">Logausgaben (lokal)</div>
    <pre id="log" class="mono" style="margin-top:10px;min-height:120px"></pre>
  </div>
</div>

<script>
  // Configure PDF.js worker to local file (offline)
  // pdfjsLib is global when importing lib/pdf.min.js
  if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'lib/pdf.worker.min.js';
  }

  const $ = (id) => document.getElementById(id);
  const logEl = $('log');
  const outEl = $('out');
  const statusEl = $('status');

  function log(...args){
    const msg = args.map(a=>typeof a==='string'?a:JSON.stringify(a,null,2)).join(' ');
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(...args);
  }

  function setStatus(s, cls){
    statusEl.textContent = s;
    statusEl.className = 'small ' + (cls||'muted');
  }

  function clearAll(){
    $('file').value = '';
    outEl.textContent = '';
    logEl.textContent = '';
    setStatus('Bereit.');
    selectedFiles = [];
  }

  let selectedFiles = [];

  const drop = $('drop');
  drop.addEventListener('dragover', (e)=>{e.preventDefault(); drop.classList.add('drag');});
  drop.addEventListener('dragleave', ()=> drop.classList.remove('drag'));
  drop.addEventListener('drop', (e)=>{
    e.preventDefault();
    drop.classList.remove('drag');
    const files = Array.from(e.dataTransfer.files||[]);
    selectedFiles = files;
    setStatus(`${files.length} Datei(en) ausgewählt.`);
  });

  $('file').addEventListener('change', (e)=>{
    selectedFiles = Array.from(e.target.files||[]);
    setStatus(`${selectedFiles.length} Datei(en) ausgewählt.`);
  });

  $('btnClear').addEventListener('click', clearAll);

  $('btnCopy').addEventListener('click', async ()=>{
    try{
      await navigator.clipboard.writeText(outEl.textContent || '');
      setStatus('In die Zwischenablage kopiert.', 'success');
    } catch (e){
      setStatus('Kopieren fehlgeschlagen (Browser Berechtigung?).', 'danger');
      log(e);
    }
  });

  $('btnDownload').addEventListener('click', ()=>{
    const blob = new Blob([outEl.textContent||''], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'anamnese-output.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
  });

  async function readFileAsArrayBuffer(file){
    return await file.arrayBuffer();
  }

  async function ocrImageBlob(blob, lang){
    // Keep existing logic intact: just ensure library is local.
    // If your project relies on specific Tesseract options, adapt here accordingly.
    const worker = await Tesseract.createWorker(lang, 1, {
      logger: m => log('tesseract:', m.status, m.progress)
    });
    try{
      const { data: { text } } = await worker.recognize(blob);
      return text;
    } finally {
      await worker.terminate();
    }
  }

  async function extractTextFromPdf(file, scale){
    const buf = await readFileAsArrayBuffer(file);
    const loadingTask = pdfjsLib.getDocument({data: buf});
    const pdf = await loadingTask.promise;
    log('PDF Seiten:', pdf.numPages);

    let full = '';
    for (let pageNum=1; pageNum<=pdf.numPages; pageNum++){
      setStatus(`PDF Seite ${pageNum}/${pdf.numPages}...`);
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({scale});

      // Attempt text layer extraction first
      const textContent = await page.getTextContent();
      const strings = textContent.items.map(it => it.str).filter(Boolean);
      const text = strings.join(' ').replace(/\s+/g,' ').trim();
      if (text && text.length > 20){
        full += text + "\n\n";
        continue;
      }

      // Fallback to OCR rendering on canvas
      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const ctx = canvas.getContext('2d', {alpha:false});
      await page.render({canvasContext: ctx, viewport}).promise;
      const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
      const ocr = await ocrImageBlob(blob, $('lang').value);
      full += ocr + "\n\n";
    }
    return full;
  }

  function guessType(file){
    const n = (file.name||'').toLowerCase();
    if (file.type === 'application/pdf' || n.endsWith('.pdf')) return 'pdf';
    if (file.type.startsWith('image/') || n.match(/\.(png|jpe?g|bmp|webp)$/)) return 'image';
    return 'other';
  }

  $('btnRun').addEventListener('click', async ()=>{
    if (!selectedFiles.length){
      setStatus('Bitte Datei(en) auswählen.', 'danger');
      return;
    }
    outEl.textContent = '';
    logEl.textContent = '';

    const lang = $('lang').value;
    const scale = Number($('scale').value || 2);

    try{
      setStatus('Starte...');
      let combined = '';

      for (const file of selectedFiles){
        log('Datei:', file.name, file.type, file.size);
        const type = guessType(file);
        if (type === 'pdf'){
          combined += `### ${file.name}\n`;
          combined += await extractTextFromPdf(file, scale);
          combined += "\n";
        } else if (type === 'image'){
          setStatus(`OCR: ${file.name}...`);
          combined += `### ${file.name}\n`;
          const blob = file;
          const text = await ocrImageBlob(blob, lang);
          combined += text + "\n\n";
        } else {
          combined += `### ${file.name}\n(Nicht unterstütztes Format)\n\n`;
        }
      }

      // Optional: if existing logic uses CryptoJS, keep it available locally.
      // No change in functional behavior here.
      if (window.CryptoJS) {
        // noop; ensures library is loaded
      }

      outEl.textContent = combined.trim() + "\n";
      setStatus('Fertig.', 'success');
    } catch (e){
      setStatus('Fehler bei der Verarbeitung. Details im Log.', 'danger');
      log(e && e.stack ? e.stack : e);
    }
  });
</script>
</body>
</html>
